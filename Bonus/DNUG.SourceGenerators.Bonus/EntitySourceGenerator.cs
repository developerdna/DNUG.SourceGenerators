using System.CodeDom.Compiler;
using System.Collections.Immutable;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using DNUG.SourceGenerators.Bonus.Source;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using YamlDotNet.Serialization;

namespace DNUG.SourceGenerators.Bonus;

[Generator(LanguageNames.CSharp)]
public class EntitySourceGenerator : IIncrementalGenerator
{
    private static readonly AssemblyName AssemblyName =
        typeof(EntitySourceGenerator).Assembly.GetName();
    
    private static readonly string Namespace = AssemblyName.Name;
    
    private const string AttributeName = "EntityContextAttribute";
    
    private static readonly string MarkerAttributeSourceCode = $$"""
                                                                 // <auto-generated/>
                                                                 namespace {{Namespace}};

                                                                 [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{AssemblyName.Name}}", "{{AssemblyName.Version}}")]
                                                                 [global::System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = false)]
                                                                 public class EntityContextAttribute : global::System.Attribute;
                                                                 """;
    
    private static readonly string MarkerFullyQualifiedMetadataName =
        $"{Namespace}.{AttributeName}";
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static ctx => ctx.AddSource($"{Namespace}.{AttributeName}.g.cs",
            SourceText.From(MarkerAttributeSourceCode, Encoding.UTF8)));
        
        var deserializer = new DeserializerBuilder().Build();
        var additionalTexts = context.AdditionalTextsProvider
            .Where(f => Path.GetFileName(f.Path) == "entities.yaml")
            .Select((text, token) => text.GetText(token)?.ToString())!
            .Collect<string>()
            .SelectMany((contents, _) =>
                contents.Select(yaml => deserializer.Deserialize<EntityConfigurationFile>(yaml)));

        var contextSource = context.SyntaxProvider
            .ForAttributeWithMetadataName(MarkerFullyQualifiedMetadataName, (node, _) =>
                    node is ClassDeclarationSyntax classDeclaration &&
                    classDeclaration.Modifiers.Any(SyntaxKind.PartialKeyword),
                (syntaxContext, _) => (INamedTypeSymbol)syntaxContext.TargetSymbol)
            .Collect();
        
        context.RegisterSourceOutput(additionalTexts, GenerateSource);
        context.RegisterSourceOutput(additionalTexts.Combine(contextSource), GenerateContext);
    }

    private void GenerateContext(SourceProductionContext context, (EntityConfigurationFile ConfigFile, ImmutableArray<INamedTypeSymbol> EntityContextSymbols) combined)
    {
        var contextSymbol = combined.EntityContextSymbols.FirstOrDefault();
        if (contextSymbol is null)
        {
            return;
        }
        
        StringBuilder builder = new();
        using StringWriter writer = new(builder, CultureInfo.InvariantCulture);
        using IndentedTextWriter sourceFile = new(writer, "    ");
        
        sourceFile.WriteLine("// <auto-generated/>");
        sourceFile.WriteLine("#nullable enable");
        sourceFile.WriteLineNoTabs(null!);
        sourceFile.WriteLine($"namespace {combined.ConfigFile.Namespace};");
        sourceFile.WriteLineNoTabs(null!);
        
        sourceFile.WriteLine($"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"{AssemblyName.Name}\", \"{AssemblyName.Version}\")]");
        sourceFile.WriteLine($"public partial class {contextSymbol.Name}");
        sourceFile.WriteLine('{');
        sourceFile.Indent++;

        foreach (var entity in combined.ConfigFile.Entities)
        {
            sourceFile.WriteLine($"public global::System.Collections.Generic.List<{entity.Name}> {entity.Name} {{ get; set; }}");
        }
        
        sourceFile.Indent--;
        sourceFile.WriteLine('}');

        context.AddSource($"{combined.ConfigFile.Namespace}.{contextSymbol.Name}.g.cs", writer.ToString());
    }

    private void GenerateSource(SourceProductionContext context, EntityConfigurationFile configFile)
    {
        foreach (var entity in configFile.Entities)
        {
            context.AddSource($"{configFile.Namespace}.{entity.Name}.g.cs",
                GenerateSourceFile(entity, configFile.Namespace));
        }
    }
    
    private static string GenerateSourceFile(Entity entity, string @namespace)
    {
        StringBuilder builder = new();
        using StringWriter writer = new(builder, CultureInfo.InvariantCulture);
        using IndentedTextWriter sourceFile = new(writer, "    ");

        sourceFile.WriteLine("// <auto-generated/>");
        sourceFile.WriteLine("#nullable enable");
        sourceFile.WriteLineNoTabs(null!);
        sourceFile.WriteLine($"namespace {@namespace};");
        sourceFile.WriteLineNoTabs(null!);
        
        sourceFile.WriteLine($"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"{AssemblyName.Name}\", \"{AssemblyName.Version}\")]");
        sourceFile.WriteLine($"public partial class {entity.Name}");
        sourceFile.WriteLine('{');
        sourceFile.Indent++;

        for (var index = 0; index < entity.Members.Length; index++)
        {
            var member = entity.Members[index];
            WriteMember(sourceFile, member);

            if (index < entity.Members.Length - 1) sourceFile.WriteLineNoTabs(null!);
        }

        sourceFile.Indent--;
        sourceFile.WriteLine('}');

        return writer.ToString();
    }

    private static void WriteMember(IndentedTextWriter sourceFile, EntityMember member)
    {
        sourceFile.WriteLine($"public {GetMemberType(member)} {member.Name} {{ get; set; }}");
    }

    private static string GetMemberType(EntityMember member) => member.Type.ToLower() switch
    {
        "boolean" => "global::System.Boolean",
        "integer" => "global::System.Int32",
        "date" => "global::System.DateTime",
        "float" => "global::System.DateTime",
        "guid" => "global::System.Guid",
        "string" => "global::System.String",
        _ => GetNonPrimitiveMemberType(member.Type)
    };

    private static string GetNonPrimitiveMemberType(string type)
    {
        return type.EndsWith("[]") ? $"global::System.Collections.Generic.List<{type}>" : type;
    }
}