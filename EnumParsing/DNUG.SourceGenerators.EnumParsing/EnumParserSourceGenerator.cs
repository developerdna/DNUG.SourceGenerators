using System;
using System.CodeDom.Compiler;
using System.Collections.Immutable;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using DNUG.SourceGenerators.EnumParsing.Comparer;
using DNUG.SourceGenerators.EnumParsing.Marker;
using DNUG.SourceGenerators.EnumParsing.Model;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace DNUG.SourceGenerators.EnumParsing;

[Generator(LanguageNames.CSharp)]
public sealed class EnumParserSourceGenerator : IIncrementalGenerator
{
    private static readonly string MarkerFullyQualifiedMetadataName =
        $"{EnumParserSourceGeneratorMarkerAttribute.Namespace}.{EnumParserSourceGeneratorMarkerAttribute.AttributeName}`1";

    private static readonly SymbolDisplayFormat GlobalFormat = SymbolDisplayFormat.FullyQualifiedFormat
        .WithMemberOptions(SymbolDisplayMemberOptions.IncludeContainingType);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static ctx => ctx.AddSource(
            $"{EnumParserSourceGeneratorMarkerAttribute.Namespace}.{EnumParserSourceGeneratorMarkerAttribute.AttributeName}.g.cs",
            SourceText.From(EnumParserSourceGeneratorMarkerAttribute.MarkerAttributeSourceCode, Encoding.UTF8)));

        var source = context.SyntaxProvider
            .ForAttributeWithMetadataName(MarkerFullyQualifiedMetadataName, Predicate, Transform)
            .Collect()
            .SelectMany(GroupByTargetClass)
            .Select(CreateTargetInfo)
            .WithComparer(EnumParserTargetInfoComparer.Instance);

        context.RegisterSourceOutput(source, GenerateClassOutput);
    }

    private static bool Predicate(SyntaxNode node, CancellationToken _)
    {
        return node is ClassDeclarationSyntax classDeclaration &&
               classDeclaration.Modifiers.Any(SyntaxKind.PartialKeyword);
    }

    private static EnumParseSyntaxTreeInfo Transform(GeneratorAttributeSyntaxContext context, CancellationToken _)
    {
        return new EnumParseSyntaxTreeInfo((INamedTypeSymbol)context.TargetSymbol, context.Attributes);
    }

    private static ImmutableArray<IGrouping<ISymbol?, EnumParseSyntaxTreeInfo>> GroupByTargetClass(
        ImmutableArray<EnumParseSyntaxTreeInfo> source, CancellationToken _)
    {
        return [..source.GroupBy(c => c.TargetSymbol, SymbolEqualityComparer.Default)];
    }

    private static EnumParserTargetInfo CreateTargetInfo(IGrouping<ISymbol?, EnumParseSyntaxTreeInfo> sources,
        CancellationToken _)
    {
        var source = sources.FirstOrDefault();
        var enumInfos = source.Attributes
            .Where(a => a.AttributeClass is not null && a.AttributeClass.TypeArguments.Length > 0)
            .Select(a => a.AttributeClass!.TypeArguments[0])
            .Select(data => new EnumInfo(data.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat),
                data.ToDisplayString(GlobalFormat), [
                    ..data.GetMembers()
                        .Where(static member => member.Kind == SymbolKind.Field)
                        .Select(static field => new EnumValue(field.Name, field.ToDisplayString(GlobalFormat)))
                ]))
            .ToImmutableArray();

        return new EnumParserTargetInfo(source.TargetSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : source.TargetSymbol.ContainingNamespace.ToDisplayString(), source.TargetSymbol.Name, enumInfos);
    }

    private static void GenerateClassOutput(SourceProductionContext context, EnumParserTargetInfo source)
    {
        context.AddSource($"{source.TargetNamespace}.{source.TargetClassName}.g.cs", GenerateSourceFile(source));
    }

    private static string GenerateSourceFile(EnumParserTargetInfo info)
    {
        StringBuilder builder = new();
        using StringWriter writer = new(builder, CultureInfo.InvariantCulture);
        using IndentedTextWriter sourceFile = new(writer, "    ");

        sourceFile.WriteLine($"// {DateTime.Now}");
        sourceFile.WriteLine("// <auto-generated/>");
        sourceFile.WriteLine("#nullable enable");
        sourceFile.WriteLineNoTabs(null!);
        sourceFile.WriteLine("using System;");
        sourceFile.WriteLineNoTabs(null!);

        if (!string.IsNullOrEmpty(info.TargetNamespace))
        {
            sourceFile.WriteLine($"namespace {info.TargetNamespace};");
            sourceFile.WriteLineNoTabs(null!);
        }

        sourceFile.WriteLine($"partial class {info.TargetClassName}");
        sourceFile.WriteLine('{');
        sourceFile.Indent++;

        for (var index = 0; index < info.Enums.Length; index++)
        {
            var enumInfo = info.Enums[index];
            WriteEnumParseMethod(sourceFile, enumInfo);

            if (index < info.Enums.Length - 1) sourceFile.WriteLineNoTabs(null!);
        }

        sourceFile.Indent--;
        sourceFile.WriteLine('}');

        return writer.ToString();
    }

    private static void WriteEnumParseMethod(IndentedTextWriter sourceFile, EnumInfo info)
    {
        const string valueArgumentName = "value";
        sourceFile.WriteLine(
            $"public static {info.FullyQualifiedName} Parse{info.EnumName}(string {valueArgumentName}) => {valueArgumentName} switch");
        sourceFile.WriteLine('{');
        sourceFile.Indent++;

        foreach (var item in info.EnumValues) sourceFile.WriteLine($@"""{item.Value}"" => {item.FullyQualifiedValue},");

        sourceFile.WriteLine($@"_ => throw new ArgumentException("""", nameof({valueArgumentName}))");
        sourceFile.Indent--;
        sourceFile.WriteLine("};");
    }
}